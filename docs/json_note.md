# Спецификация формата JSON для `code-validator`

Скрипт `code-validator` предназначен для автоматизированного статического анализа кода на языке Python. Он принимает на
вход путь к файлу с решением и путь к JSON-файлу, описывающему один **набор правил валидации**. Набор правил — это
логическая группа из одного или нескольких атомарных **правил ("rules")**, применяемых к коду студента.

## Оглавление

1. [Общая структура JSON](#1-общая-структура-json)
2. [Структура объекта атомарного правила (`rule`)](#2-структура-объекта-атомарного-правила-rule)
3. [Обзор "коротких" правил](#3-обзор-коротких-правил-type)
    * [3.1 `check_syntax`](#31-check_syntax)
    * [3.2 `check_linter_pep8`](#32-check_linter_pep8)
4. [Обзор "полных" правил (`check`)](#4-обзор-полных-правил-check)
    * [4.1 Селекторы (`selector`) — *Что* и *где* искать](#41-селекторы-selector--что-и-где-искать)
    * [4.2 Ограничения (`constraint`) — *Какому
      условию* проверять](#42-ограничения-constraint--какому-условию-проверять)
5. [Практические примеры и "Книга рецептов"](#5-практические-примеры-и-книга-рецептов)
    * [5.1 Проверка структуры: функции, классы, импорты](#51-проверка-структуры-функции-классы-импорты)
    * [5.2 Проверка реализации: запрет конструкций, проверка сигнатур](#52-проверка-реализации-запрет-конструкций-проверка-сигнатур)
    * [5.3 Проверка стиля и "магических" значений](#53-проверка-стиля-и-магических-значений)

---

## 1. Общая структура JSON

Каждый файл правил должен содержать один JSON-объект со следующей структурой.

```json
{
  "file_type": "python",
  "description": "Набор правил для проверки задачи 'Навигационный Крест'.",
  "validation_rules": [
    // ... массив объектов правил ...
  ]
}
```

### Ключевые поля:

- **`file_type`**: `string`
    - **Обязательность**: Да
    - **Описание**: Определяет язык анализируемого кода. На данный момент должно быть всегда `"python"`.
- **`description`**: `string`
    - **Обязательность**: Нет (опционально)
    - **Описание**: Человекочитаемое описание всего набора правил. Используется для документирования.
- **`validation_rules`**: `array` из объектов `rule`
    - **Обязательность**: Да
    - **Описание**: Список атомарных правил, которые будут последовательно применены к коду.

---

## 2. Структура объекта атомарного правила (`rule`)

Каждый элемент в массиве `validation_rules` представляет одно конкретное правило.

```json
{
  "rule_id": 101,
  "message": "Необходимо определить функцию с именем `solve`.",
  "is_critical": true,
  "check": {
    "selector": {
      "type": "function_def",
      "name": "solve"
    },
    "constraint": {
      "type": "is_required"
    }
  }
}
```

### Ключевые поля:

- **`rule_id`**: `integer`
    - **Обязательность**: Да
    - **Описание**: Уникальный числовой идентификатор для этого правила. Используется для логирования и отладки.
- **`message`**: `string`
    - **Обязательность**: Да
    - **Описание**: Сообщение об ошибке, которое будет показано студенту, если это правило не будет выполнено.
- **`is_critical`**: `boolean`
    - **Обязательность**: Нет (опционально, по умолчанию `false`)
    - **Описание**: Если установлено в `true`, то в случае провала этого правила вся дальнейшая валидация будет
      немедленно остановлена. Это полезно для базовых проверок (например, синтаксис или наличие основной функции), без
      которых остальные проверки не имеют смысла.
- **Ключи логики правила**: Каждое правило должно содержать либо ключ `"type"` (для "коротких" правил), либо ключ
  `"check"` (для "полных" правил).

---

## 3. Обзор "коротких" правил (`type`)

"Короткие" правила — это готовые проверки для самых частых задач. Они просты в использовании и не требуют написания
`selector` и `constraint`.

### 3.1 `check_syntax`

Проверяет код на наличие синтаксических ошибок (`SyntaxError`). Эта проверка всегда выполняется самой первой, независимо
от ее положения в списке. Включение этого правила в JSON позволяет задать кастомное сообщение об ошибке.

- **Параметры (`params`)**: Нет.

- **Пример:**
  ```json
  {
    "rule_id": 1,
    "type": "check_syntax",
    "message": "В вашем коде есть синтаксические ошибки. Пожалуйста, проверьте его внимательно перед отправкой."
  }
  ```

### 3.2 `check_linter_pep8`

Запускает линтер `flake8` для проверки кода на соответствие стандарту стиля PEP8 и поиска распространенных ошибок (
например, неиспользуемые импорты).

- **Параметры (`params`):**
    - `ignore` (`array` из `string`, опционально): Список кодов ошибок `flake8`, которые нужно игнорировать (например,
      `["E501"]` для игнорирования слишком длинных строк).
    - `select` (`array` из `string`, опционально): Список кодов ошибок, которые нужно **эксклюзивно** проверить. Если
      указан `select`, параметр `ignore` игнорируется. По умолчанию проверяются все основные категории (`E`, `W`, `F`).

- **Пример:**
  ```json
  {
    "rule_id": 2,
    "type": "check_linter_pep8",
    "message": "Код не соответствует стандарту PEP8. Пожалуйста, проверьте отступы и стиль вашего кода.",
    "params": {
      "ignore": ["E501", "W292"]
    }
  }
  ```

---

### **Часть 2 из 3: Полные правила и справочник по Селекторам**

## 4. Обзор "полных" правил (`check`)

"Полные" правила дают вам максимальную гибкость. Они позволяют находить практически любую конструкцию в коде и применять
к ней логические условия. Каждое полное правило состоит из двух частей: `selector` и `constraint`.

```json
{
  "rule_id": 201,
  "message": "...",
  "check": {
    "selector": {
      // ... что и где искать ...
    },
    "constraint": {
      // ... какому условию должны соответствовать найденные элементы ...
    }
  }
}
```

### 4.1 Селекторы (`selector`) — *Что* и *где* искать

Селекторы отвечают за поиск нужных элементов в Abstract Syntax Tree (AST) кода.

#### Общий параметр `in_scope`

Большинство селекторов поддерживают необязательный параметр `in_scope`, чтобы ограничить область поиска.

.. list-table::
:widths: 25 75
:header-rows: 1

*
    - Значение `in_scope`
    - Описание
*
    - ``"global"``
    - Искать только в глобальной области видимости модуля.
*
    - ``{ "function": "my_func" }``
    - Искать только внутри функции ``my_func``.
*
    - ``{ "class": "MyClass" }``
    - Искать только внутри тела класса ``MyClass`` (но не внутри его методов).
*
    - ``{ "class": "MyClass", "method": "my_method" }``
    - Искать только внутри метода ``my_method`` класса ``MyClass``.

#### Справочник по типам селекторов

---

##### `function_def`

Находит определения функций (`def` ...).

- **JSON `type`**: `"function_def"`
- **Параметры**:
    - `name` (`string`): Имя функции. Используйте `"*"` для поиска всех функций в заданной области.

- **Пример:** Найти все методы внутри класса `MyGame`.
  ```json
  "selector": {
    "type": "function_def",
    "name": "*",
    "in_scope": { "class": "MyGame" }
  }
  ```

---

##### `class_def`

Находит определения классов (`class` ...).

- **JSON `type`**: `"class_def"`
- **Параметры**:
    - `name` (`string`): Имя класса. Используйте `"*"` для поиска всех классов.

- **Пример:** Найти определение класса `Player`.
  ```json
  "selector": {
    "type": "class_def",
    "name": "Player"
  }
  ```

---

##### `import_statement`

Находит инструкции `import` и `from ... import`.

- **JSON `type`**: `"import_statement"`
- **Параметры**:
    - `name` (`string`): Имя искомого модуля. Этот селектор найдет `import os`, `import os.path`, а также
      `from os import path`.

- **Пример:** Найти импорт модуля `arcade`.
  ```json
  "selector": {
    "type": "import_statement",
    "name": "arcade"
  }
  ```

---

##### `function_call`

Находит вызовы функций и методов.

- **JSON `type`**: `"function_call"`
- **Параметры**:
    - `name` (`string`): Полное имя вызываемой функции (например, `"print"`, `"requests.get"`).

- **Пример:** Найти все вызовы `arcade.run()`.
  ```json
  "selector": {
    "type": "function_call",
    "name": "arcade.run"
  }
  ```

---

##### `assignment`

Находит инструкции присваивания (`=`), включая присваивания с аннотацией типа (`x: int = 5`).

- **JSON `type`**: `"assignment"`
- **Параметры**:
    - `name` (`string`): Полное имя переменной или атрибута, которому присваивается значение (например, `"score"`,
      `"self.player"`). Используйте `"*"` для поиска всех присваиваний.

- **Пример:** Найти, где инициализируется атрибут `self.score`.
  ```json
  "selector": {
    "type": "assignment",
    "name": "self.score",
    "in_scope": { "class": "MyGame", "method": "__init__" }
  }
  ```

---

##### `usage`

Находит места, где переменная или атрибут используется (читается).

- **JSON `type`**: `"usage"`
- **Параметры**:
    - `name` (`string`): Имя используемой переменной или атрибута.

- **Пример:** Найти все случаи использования константы `SCREEN_WIDTH`.
  ```json
  "selector": {
    "type": "usage",
    "name": "SCREEN_WIDTH"
  }
  ```

---

##### `literal`

Находит "голые" значения (литералы) в коде, такие как числа и строки. Этот селектор достаточно умен, чтобы игнорировать
докстринги и части f-строк, что помогает избежать ложных срабатываний при поиске "магических значений".

- **JSON `type`**: `"literal"`
- **Параметры**:
    - `name` (`string`): Тип искомого литерала. Поддерживаемые значения: `"number"` или `"string"`.

- **Пример:** Найти все числовые литералы внутри функции `calculate_price`.
  ```json
  "selector": {
    "type": "literal",
    "name": "number",
    "in_scope": { "function": "calculate_price" }
  }
  ```

---

##### `ast_node`

Универсальный низкоуровневый селектор для поиска любого узла AST по имени его класса из модуля `ast`.

- **JSON `type`**: `"ast_node"`
- **Параметры**:
    - `node_type` (`string` или `array` из `string`): Имя класса узла (например, `"While"`, `"Try"`) или их список.

- **Пример:** Найти все циклы `for` и `while` в коде.
  ```json
  "selector": {
    "type": "ast_node",
    "node_type": ["For", "While"]
  }
  ```

---

### 4.2 Ограничения (`constraint`) — *Какому условию* проверять

Ограничения принимают список узлов, найденных селектором, и выносят вердикт: `true` (проверка пройдена) или `false` (
правило нарушено).

#### Справочник по типам ограничений

---

##### `is_required`

Проверяет, что селектор нашел хотя бы один узел. Используется для проверки наличия обязательных элементов.

- **JSON `type`**: `"is_required"`
- **Параметры**:
    - `count` (`integer`, опционально): Если указано, требует, чтобы количество найденных узлов было **в точности**равно
      этому числу.

- **Пример:** Убедиться, что в коде есть ровно одна функция с именем `main`.
  ```json
  "constraint": { "type": "is_required", "count": 1 }
  ```

---

##### `is_forbidden`

Проверяет, что селектор **не нашел** ни одного узла. Используется для запрета конструкций.

- **JSON `type`**: `"is_forbidden"`
- **Параметры**: Нет.

- **Пример:** Убедиться, что вызовы функции `eval` отсутствуют.
  ```json
  "constraint": { "type": "is_forbidden" }
  ```

---

##### `must_inherit_from`

Проверяет, что класс, найденный селектором `class_def`, наследуется от указанного родителя.

- **JSON `type`**: `"must_inherit_from"`
- **Параметры**:
    - `parent_name` (`string`): Ожидаемое имя родительского класса (например, `"Exception"` или `"arcade.Window"`).

- **Пример:** Проверить, что класс `MyGame` является потомком `arcade.Window`.
  ```json
  "constraint": { "type": "must_inherit_from", "parent_name": "arcade.Window" }
  ```

---

##### `must_be_type`

Проверяет тип значения, присваиваемого переменной (работает с селектором `assignment`). Поддерживает простые литералы и
вызовы конструкторов (`list()`, `dict()`).

- **JSON `type`**: `"must_be_type"`
- **Параметры**:
    - `expected_type` (`string`): Имя требуемого типа. Поддерживаются: `"str"`, `"int"`, `"float"`, `"list"`, `"dict"`,
      `"bool"`, `"set"`, `"tuple"`.

- **Пример:** Проверить, что константе `SPEED` присваивается числовое значение.
  ```json
  "constraint": { "type": "must_be_type", "expected_type": "int" }
  ```

---

##### `must_have_args`

Проверяет сигнатуру функции или метода (работает с селектором `function_def`).

- **JSON `type`**: `"must_have_args"`
- **Параметры**:
    - `count` (`integer`, опционально): Точное количество аргументов (не включая `self`/`cls`).
    - `names` (`array` из `string`, опционально): Точный список имен аргументов в правильном порядке.
    - `exact_match` (`boolean`, опционально): Используется с `names`. Если `false`, проверяет только наличие указанных
      имен, а не точное совпадение списка. По умолчанию `true`.

- **Пример:** Проверить, что метод `__init__` принимает аргументы `width` и `height`.
  ```json
  "constraint": { "type": "must_have_args", "names": ["width", "height"] }
  ```

---

##### `name_must_be_in`

Проверяет, что **имена** всех найденных селектором узлов (функций, классов, переменных) входят в разрешенный список.

- **JSON `type`**: `"name_must_be_in"`
- **Параметры**:
    - `allowed_names` (`array` из `string`): Список разрешенных имен.

- **Пример:** Разрешить создание только определенных глобальных констант.
  ```json
  "constraint": {
    "type": "name_must_be_in",
    "allowed_names": ["SCREEN_WIDTH", "SCREEN_HEIGHT", "TITLE"]
  }
  ```

---

##### `value_must_be_in`

Проверяет, что **значения** всех найденных селектором литералов входят в разрешенный список. Основной инструмент для
борьбы с "магическими числами/строками".

- **JSON `type`**: `"value_must_be_in"`
- **Параметры**:
    - `allowed_values` (`array`): Список разрешенных значений (например, `[0, 1]`, `["OK", "ERROR"]`).

- **Пример:** Разрешить использование только чисел 0 и 1 в качестве литералов.
  ```json
  "constraint": {
    "type": "value_must_be_in",
    "allowed_values": [0, 1]
  }
  ```

---

## 5. Практические примеры и "Книга рецептов"

Ниже приведены комплексные примеры, демонстрирующие, как комбинировать селекторы и ограничения для решения реальных
задач.

### 5.1 Проверка структуры: функции, классы, импорты

**Задача:** Убедиться, что в файле есть класс `MyGame`, унаследованный от `arcade.Window`, и в нем есть метод `on_draw`.

```json
{
  "description": "Проверка базовой структуры Arcade-приложения",
  "validation_rules": [
    {
      "rule_id": 1,
      "message": "Класс 'MyGame' должен наследоваться от 'arcade.Window'.",
      "check": {
        "selector": {
          "type": "class_def",
          "name": "MyGame"
        },
        "constraint": {
          "type": "must_inherit_from",
          "parent_name": "arcade.Window"
        }
      }
    },
    {
      "rule_id": 2,
      "message": "В классе 'MyGame' должен быть определен метод 'on_draw'.",
      "check": {
        "selector": {
          "type": "function_def",
          "name": "on_draw",
          "in_scope": {
            "class": "MyGame"
          }
        },
        "constraint": {
          "type": "is_required"
        }
      }
    }
  ]
}
```

### 5.2 Проверка реализации: запрет конструкций, проверка сигнатур

**Задача:** Для рекурсивной функции `factorial` запретить использование циклов и убедиться, что она принимает ровно один
аргумент.

```json
{
  "description": "Проверка рекурсивной реализации факториала",
  "validation_rules": [
    {
      "rule_id": 1,
      "message": "В рекурсивной функции 'factorial' запрещено использовать циклы.",
      "check": {
        "selector": {
          "type": "ast_node",
          "node_type": [
            "For",
            "While"
          ],
          "in_scope": {
            "function": "factorial"
          }
        },
        "constraint": {
          "type": "is_forbidden"
        }
      }
    },
    {
      "rule_id": 2,
      "message": "Функция 'factorial' должна принимать один аргумент.",
      "check": {
        "selector": {
          "type": "function_def",
          "name": "factorial"
        },
        "constraint": {
          "type": "must_have_args",
          "count": 1
        }
      }
    }
  ]
}
```

### 5.3 Проверка стиля и "магических" значений

**Задача:** Убедиться, что в коде нет строковых литералов, кроме тех, что используются для ключей словаря.

```json
{
  "description": "Проверка на отсутствие магических строк",
  "validation_rules": [
    {
      "rule_id": 1,
      "message": "В коде найдены необъявленные строковые литералы.",
      "check": {
        "selector": { "type": "literal", "name": "string" },
        "constraint": {
          "type": "value_must_be_in",
          "allowed_values": ["name", "age", "city"]
        }
      }
    }
  ]
}