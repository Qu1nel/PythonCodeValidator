# Chapter 9: Ограничение (Constraint)

В [Chapter 8: Обработчик области видимости (Scope Handler)](08_обработчик_области_видимости__scope_handler__.md) мы
узнали, как ограничить область поиска в нашем коде. Теперь, когда мы выбрали нужные элементы кода с
помощью [Селектора (Selector)](07_селектор__selector__.md), как мы убедимся, что эти элементы соответствуют нашим
требованиям? Для этого нам нужны Ограничения (Constraints)!

Ограничение (Constraint) — это условие, которое мы хотим проверить для выбранных элементов кода. Это как сказать: "Мы
выбрали все яблоки, теперь убедимся, что они красные". Ограничение говорит, какое свойство этих яблок (элементов кода)
мы будем проверять. Если свойство не соответствует (например, яблоко зеленое), значит правило нарушено.

**Зачем нужны Ограничения (Constraints)?**

Представьте, что вы проверяете пароли на соответствие определенным правилам. Например, пароль должен содержать не менее
8 символов, иметь хотя бы одну цифру и одну заглавную букву. Каждое из этих требований — это отдельное ограничение (
Constraint). Ограничения позволяют нам задавать правила, которым должен соответствовать наш код.

**Центральный пример использования:**

Допустим, мы хотим убедиться, что все функции в нашем коде имеют документацию (docstring). Мы можем
использовать [Селектор (Selector)](07_селектор__selector__.md), чтобы выбрать все определения функций, а затем
использовать Ограничение (Constraint), чтобы проверить, имеет ли каждая из этих функций docstring. Если функция не имеет
docstring, это будет считаться нарушением правила.

**Ключевые концепции Ограничения (Constraint):**

1. **Условие (Condition):**  Фактически, это логическое выражение, которое возвращает `True` (истина), если условие
   выполнено, и `False` (ложь), если условие не выполнено.
2. **Применение к выбранным узлам (Applying to Selected Nodes):** Ограничение применяется к списку узлов,
   выбранных [Селектором (Selector)](07_селектор__selector.md).
3. **Результат проверки (Check Result):** Результат проверки показывает, соответствует ли выбранный узел заданному
   условию.

**Как использовать Ограничение (Constraint):**

В `PythonCodeValidator`, все ограничения реализуют интерфейс `Constraint` (определен в
`src\code_validator\components\definitions.py`). Чтобы создать и использовать Ограничение (Constraint), нужно:

1. Выбрать нужный тип ограничения (например, `IsRequiredConstraint`, `IsForbiddenConstraint`, `MustHaveArgsConstraint`).
2. Создать объект ограничения, передав ему необходимые параметры (например, ожидаемое значение, список разрешенных
   имен).
3. Вызвать метод `check()`, передав ему список узлов, выбранных [Селектором (Selector)](07_селектор__selector.md). Метод
   вернет `True`, если все узлы соответствуют условию, и `False` в противном случае.

Давайте рассмотрим пример:

```python
import ast
from src.code_validator.rules_library.constraint_logic import IsRequiredConstraint

# 1. Список узлов (предположим, что Selector их уже нашел)
nodes = [ast.FunctionDef(name="my_function")]  # Предположим, есть функция с именем "my_function"

# 2. Создаем ограничение "обязательно наличие"
constraint = IsRequiredConstraint()

# 3. Проверяем ограничение
result = constraint.check(nodes)

# 4. Проверяем результат
if result:
    print("Ограничение выполнено!")  # Вывод: Ограничение выполнено!
else:
    print("Ограничение не выполнено.")
```

Этот код создает ограничение `IsRequiredConstraint`, которое проверяет, что список узлов не пуст. В данном случае,
список узлов не пуст, поэтому ограничение выполнено.

Рассмотрим другие примеры ограничений:

* `IsForbiddenConstraint`: Проверяет, что список узлов пуст (то есть, ни один узел не был
  найден [Селектором (Selector)](07_селектор__selector.md)).
* `MustInheritFromConstraint`: Проверяет, что класс наследуется от определенного класса. Например,
  `MustInheritFromConstraint(parent_name="Exception")` проверит, что класс наследуется от `Exception`.
* `MustBeTypeConstraint`: Проверяет, что переменная имеет определенный тип. Например,
  `MustBeTypeConstraint(expected_type="int")` проверит, что переменная имеет тип `int`.
* `MustHaveArgsConstraint`: Проверяет, что функция имеет определенное количество аргументов или определенные имена
  аргументов.

**Пример конфигурации ограничения в `my_rules.json`:**

```json
{
  "constraint": {
    "type": "is_required"
  }
}
```

В этом примере, `type` указывает на тип ограничения (`is_required`).

Давайте посмотрим на более сложный пример:

```json
{
  "constraint": {
    "type": "must_have_args",
    "count": 2
  }
}
```

В этом примере мы проверяем, что выбранная функция имеет 2 аргумента.

**Внутренняя реализация Ограничения (Constraint):**

Что происходит под капотом, когда вы вызываете метод `check()`?

**Шаги работы (без кода):**

1. Метод `check()` получает список узлов, выбранных [Селектором (Selector)](07_селектор__selector.md).
2. Метод `check()` выполняет проверку на основе типа ограничения.
3. Метод `check()` возвращает `True`, если все узлы соответствуют условию, и `False` в противном случае.

**Упрощенная диаграмма последовательности:**

```mermaid
sequenceDiagram
    participant Constraint
    participant AST Node
    participant Result

    Constraint->>AST Node: Получение узла
    loop Для каждого узла
        Constraint->>Constraint: Выполнение проверки
        alt Условие нарушено
            Constraint-->>Result: False
            break
        end
    end
    Constraint-->>Result: True
```

**Пример кода из `src\code_validator\rules_library\constraint_logic.py` (IsRequiredConstraint):**

```python
# src/code_validator/rules_library/constraint_logic.py
import ast


class IsRequiredConstraint:
    def check(self, nodes: list[ast.AST]) -> bool:
        """Проверяет, что список узлов не пуст."""
        return len(nodes) > 0
```

Этот код показывает, как `IsRequiredConstraint` просто проверяет, что список узлов не пуст.

**Пример кода из `src\code_validator\rules_library\constraint_logic.py` (MustHaveArgsConstraint):**

```python
# src/code_validator/rules_library/constraint_logic.py
import ast


class MustHaveArgsConstraint:
    def __init__(self, **kwargs):
        self.expected_count = kwargs.get("count")

    def check(self, nodes: list[ast.AST]) -> bool:
        """Проверяет, что функция имеет определенное количество аргументов."""
        if not nodes:
            return True
        for node in nodes:
            if not isinstance(node, ast.FunctionDef):
                return False
            arg_count = len(node.args.args)
            if arg_count != self.expected_count:
                return False
        return True
```

Этот код показывает, как `MustHaveArgsConstraint` проверяет, что функция имеет определенное количество аргументов.

**Заключение:**

В этой главе мы познакомились с Ограничениями (Constraints) – инструментом для проверки соответствия выбранных узлов
определенным требованиям. Мы узнали, какие типы ограничений существуют, как использовать ограничения для проверки кода,
и как ограничения работают "под капотом". Теперь вы понимаете, как `PythonCodeValidator` использует ограничения для
проверки правил валидации кода!

Поздравляю! На этом заканчивается наш курс по `PythonCodeValidator`. У вас теперь есть знания об основных компонентах
этого инструмента, включая CLI, конфигурацию, валидатор, правила, фабрики, AST, селекторы, обработчик области видимости
и ограничения. Спасибо за прохождение этого курса!